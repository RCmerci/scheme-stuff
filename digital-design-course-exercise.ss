;;;make-wire
(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (get-signal-value)
      signal-value)
    (define (set-signal-value! value)
      (if (not (equal? value signal-value))
          (begin
            (set! signal-value value)
            (call-each action-procedures)
            'done)
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch action)
      (cond ((equal? action 'get-signal)
             (get-signal-value))
            ((equal? action 'set-signal!)
             set-signal-value!)
            ((equal? action 'add-action!)
             accept-action-procedure!)
            (else
             (error "unknown operation -- WIRE" action))))
    dispatch))
(define (call-each actions)
  (if (not (null? actions))
      (begin
        ((car actions))
        (call-each (cdr actions)))
      'done))
;;; get-signal,set-signal!,add-action!
(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire value)
  ((wire 'set-signal!) value))
(define (add-action! wire proc)
  ((wire 'add-action!) proc))
;;;inverter,and-gate,or-gate
(define (inverter input output)
  (define (invert-input)
    (after-delay inverter-delay
                 (lambda ()
                   (set-signal! output
                                (logical-not (get-signal input))))))
  (add-action! input invert-input))
(define (and-gate input1 input2 output)
  (define (and-gate-action)
    (after-delay and-gate-delay
                 (lambda ()
                   (if (= 2 (+ (get-signal input1) (get-signal input2)))
                       (set-signal! output 1)
                       (set-signal! output 0)))))
  (add-action! input1 and-gate-action)
  (add-action! input2 and-gate-action))
(define (or-gate input1 input2 output)
  (define (or-gate-action)
    (after-delay or-gate-delay
                 (lambda ()
                   (if (= 0 (+ (get-signal input1) (get-signal input2)))
                       (set-signal! output 0)
                       (set-signal! output 1)))))
  (add-action! input1 or-gate-action)
  (add-action! input2 or-gate-action))
(define (logical-not value)
  (cond ((= value 0) 1)
        (else 0)))
(define (after-delay delay-time func)
  (add-to-agenda! agenda (+ (current-time agenda) delay-time) func))
;;;agenda的结构：(current-time (1 action-1 action-2 ...) (2 action-1 action-2 ...))
(define (make-agenda)
  (list 0))
(define (empty-agenda? agenda)
  (if (null? (cdr agenda))
      #t
      #f))
(define (get-segments agenda)
  (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (empty-segments? segments);;;;;;useless function
  (if (null? (cdr segments))
      #t
      #f))
(define (empty-segment? segment)
  (if (null? (cdr segment))
      #t
      #f))
(define (get-first-segment agenda)
  (car (get-segments agenda)))
(define (get-first-not-empty-segment agenda)
  (let ((result (get-first-segment agenda)))
    (cond ((not (empty-segment? result))
           result)
          ((empty-agenda? agenda)
           (error "empty-agenda --get-first-not-empty-segment" agenda))
          (else
           (get-first-not-empty-segment (cdr agenda))))))
(define (first-agenda-item! agenda)
  (if (empty-agenda? agenda)
      'all-done
      (let ((segment (get-first-not-empty-segment agenda)))
        (let ((action (cadr segment)) (time (car segment)))
          (remove-first-agenda-item! segment)
          (if (empty-segment? segment)
              (remove-first-segment! agenda))
          (list action time)))))
(define (remove-first-agenda-item! segment)
  (set-cdr! segment (cddr segment)))
(define (remove-first-segment! agenda)
  (set-cdr! agenda (cddr agenda)))
(define (current-time agenda)
  (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (add-to-agenda! agenda time action)
  (define (search-agenda)
    (define (do-search the-segments last-one)
      (cond ((null? the-segments)
             (list 'last last-one))
            ((= time (caar the-segments))
             (list '= the-segments))
            ((< time (caar the-segments))
             (list '< the-segments))
            (else
             (do-search (cdr the-segments) the-segments))))
    (do-search (get-segments agenda) #f))
  (define (make-segment)
    (list time action))
  (define (insert-to-agenda! location type)
    (cond ((eq? type '=)
           (set-cdr! (car location) (cons action (cdar location))))
          ((eq? type '<)
           (let ((temp (car location)))
             (set-car! location (make-segment))
             (set-cdr! location (cons temp (cdr location)))))
          ((eq? type 'last)
           (if location
               (begin
                 (set-cdr! location (list (make-segment))))
               (set-cdr! agenda (list (make-segment)))))))
  (define (do-add)
    (let ((result (search-agenda)))
      (insert-to-agenda! (cadr result) (car result))))
  (do-add))
;;;;;;start~
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
(define agenda (make-agenda))
(define (start)
  (define (run)
    (if (empty-agenda? agenda)
        'all-done
        (begin
          (let ((action+time (first-agenda-item! agenda)))
            (set-current-time! agenda (cadr action+time))
            ( (car action+time))
            (run)))))
  (run))
(define (ob wire nickname)
  (define (do-ob)
    (display nickname)
    (display ":")
    (display (get-signal wire))
    (newline)
    (display "current-time:")
    (display (current-time agenda))
    (newline)
    (display "------------")
    (newline))
  (add-action! wire do-ob))
;;;;;;;;;;;;;以上是实现;;;;;;;;;;;;;;;;;;;;;;;;;;;
